<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Globalization" #>
/*
 *
 * Copyright (c) 2016, Austin Wise.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 *     * Neither the name of the Austin.Linode Project, Austin Wise, nor the names
 *       of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written
 *       permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Globalization;

namespace Austin.Linode
{
partial class LinodeClient
{
<#
int[] ver = new int[4];
string[] splits = SPEC.Version.Split('.');
for (int i = 0; i < splits.Length; i++)
{
	ver[i] = int.Parse(splits[i], CultureInfo.InvariantCulture);
}
#>
        /// <summary>
        /// From what version of the API spec was this code generated from.
        /// </summary>
	public readonly Version GeneratedApiVersion = new Version(<#= ver[0] #>, <#= ver[1] #>, <#= ver[2] #>, <#= ver[3] #>);
<#
    foreach (var meth in SPEC.Methods.OrderBy(kvp => kvp.Key))
    {
		if (meth.Key == "api.spec")
			continue; //this is created manually, otherwise there is a chicken/egg problem

		Type returnType = typeof(void);
		if (mReturnType.ContainsKey(meth.Key))
			returnType = mReturnType[meth.Key];

        int firstPeriodNdx = meth.Value.Description.IndexOf(". ");
        string summary, remarks;
        if (firstPeriodNdx < 0)
        {
            summary = meth.Value.Description.Trim();
            remarks = null;
        }
        else
        {
            summary = meth.Value.Description.Substring(0, firstPeriodNdx + 1).Trim();
            remarks = meth.Value.Description.Substring(firstPeriodNdx + 2).Trim();
        }
#>

        /// <summary>
        /// <#= summary #>
        /// </summary>
<#
                if (remarks != null)
                {
                
#>
        /// <remarks>
        /// <#= remarks #>
        /// </remarks>
<#
                }
                if (!string.IsNullOrEmpty(meth.Value.Throws))
                {
#>
        /// <exception cref="LinodeException">possible errors: <#= meth.Value.Throws #></exception>
<#
                }
	        foreach (var param in SortParams(meth.Value.Parameters))
                {
#>
        /// <param name="<#= param.Key #>"><#= param.Value.Description #></param>
<#
                }
#>
	public <#= PrettyPrintType(returnType) #> <#= MethodName(meth.Key) #>(
<#
		int paramCount = meth.Value.Parameters.Count();
		PushIndent(new string(' ', 12));
		foreach (var param in SortParams(meth.Value.Parameters))
		{
			Write(ParamDec(param.Key, param.Value));
			if (--paramCount != 0)
			{
				WriteLine(", ");
			}
		}
		PopIndent();
#>
	)
	{
<#
		if (meth.Value.HasParameters)
			WriteLine("var myParams = new Dictionary<string, string>();");
		foreach (var param in SortParams(meth.Value.Parameters))
		{
			if (!param.Value.Required)
			{
#>
		if (<#= param.Key #> != null)
<#
			}
#>
		myParams.Add("<#= param.Key #>", <#= param.Key #><#= ToStringPostfix(param.Value) #>);
<#
		}
		if (returnType != typeof(void))
		{
			Write("return ");
		}
#>
		GetResponse< <#= returnType == typeof(void) ? "object" : PrettyPrintType(returnType) #> >("<#= meth.Key #>", <#= meth.Value.HasParameters ? "myParams" : "null" #>);
	}
<#
    }
#>
}
}